ORG 0x292

STR: WORD 0x5D3 ; адрес начала
SR: WORD 0x5 ; адрес регистра статуса 
DR: WORD 0x4 ; адрес регистра данных
MASK: WORD 0x40 ; маска для проверки бита готовности
M: WORD 0x00FF ; выделение младшего байта
STOP: WORD 0x0 ; Константа для сравнения (0) 
LEN: WORD 0x0 ; Переменная для длины 
BUF: WORD 0x0 ; Буфер для сборки двух символов 
CNT: WORD 0x0 ; Счетчик символов
R1: WORD 0x0

START: 
    CLA 
    LD STR 
    ST R1 ; Сохранение в R1 (указатель на память)

S1: ; ввод длины
    IN SR
    AND MASK ; Проверка бита готовности (0x40) 
    BEQ S1 ; если бит 6 = 0 (не готово), ждем
    LD DR 
    AND M
    ST LEN 
    ST CNT
    INC
    ST R1
    CMP STOP
    BEQ F 
    LD LEN
    CLA
    ST BUF

S2:
    IN SR ; Читаем регистр статуса 
    AND MASK ; Проверяем бит готовности 
    BEQ S2 ; Если не готово, ждем 
    LD DR ; Читаем первый символ из DR 
    ST BUF ; Сохраняем символ в буфер
    LD CNT ; Загружаем счетчик символов 
    DEC ; Уменьшаем счетчик на 1 
    ST CNT ; Сохраняем обновленный счетчик 
    CMP STOP ; Остался один символ? (CNT = 0) 
    BEQ SAVE_LAST ; Если да, сохраняем последний символ

S3: 
    IN SR ; Читаем регистр статуса 
    AND MASK ; Проверяем бит готовности 
    BEQ S3 ; Если не готово, ждем 
    LD DR ; Читаем второй символ 
    SWAB ; Перемещаем символ в старший байт 
    AND BUF
    ST (R1)
    LD R1
    INC
    ST R1
    LD CNT ; Загружаем счетчик 
    DEC ; Уменьшаем счетчик на 1 
    ST CNT ; Сохраняем 
    CMP STOP ; Символы закончились? (CNT = 0) 
    BEQ F ; Если да, завершаем 
    CLA ; Очищаем аккумулятор 
    ST BUF ; Очищаем буфер для следующей пары символов 
    JUMP S2 ; Возвращаемся к вводу следующей пары

SAVE_LAST: 
    LD BUF ; Загружаем последний символ из буфера 
    ST (R1) ; Сохраняем его в память (младший байт)

F:
    HLT

END